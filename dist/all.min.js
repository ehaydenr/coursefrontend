(function () {
    "use strict";

    var scheedule = angular.module('scheedule', ['ngRoute','ngResource','ngRoute','ui.bootstrap', 'angular-chartist', 'angular.filter']);
    console.log("Initialized Scheedule2 Angular.js application.");

    scheedule.config(['$routeProvider','$locationProvider', function ($routeProvider,$locationProvider) {
        $locationProvider.html5Mode(false);

        $routeProvider
            .when('/', {
                redirectTo  : '/index'
            })
            .when('/index', {
                templateUrl : '/views/index.html',
                controller  : 'IndexController',
                controllerAs: 'index'
            })
            .when('/schedule-viewer', {
                templateUrl : '/views/schedule-viewer.html',
                controller  : 'ScheduleViewerController',
                controllerAs: 'viewer'
            })
            .when('/manual-builder', {
                templateUrl : '/views/manual-builder.html',
                controller  : 'ManualBuilderController',
                controllerAs: 'mb'
            })
            .when('/auto-builder', {
                templateUrl : '/views/auto-builder.html',
                controller  : 'AutoBuilderController',
                controllerAs: 'ab'
            });
    }]);
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('AutoBuilderController', AutoBuilderController);

	/* @ngInject */
	function AutoBuilderController () {
	    var ab = this;

	    ab.init = function () {
	    	console.log("Loaded auto builder controller.");
	    }

	    ab.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('IndexController', IndexController);

	function IndexController () {
    	var index = this;

    	index.init = function () {
    		console.log("Loaded index controller.");

    		index.message = "Angular in action!";
    	}

    	index.init();
	}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .controller('ManualBuilderController', ['$rootScope','AuthService','CourseDataService', 'AgendaService', ManualBuilderController]);

    // Manual Agenda Builder Controller
    // ----------------
    //
    // Coordinates creating of agenda view, course selection accordions,
    // course searching and agenda/accordion interactions.
    function ManualBuilderController ($rootScope, AuthService, CourseDataService, AgendaService) {
        var mb = this;
        mb.init = function () {
            console.log("Loaded manual builder controller.");
            mb.courses = [];
            mb.as = AgendaService;

            // Load courses from Course Data Service.
            CourseDataService.getCourses(function (someCourses) {
                for (var course of someCourses) {
                    mb.courses.push(course);
                }
            }, function (err) {
                console.log("Couldn't load course data from backend.");
            });

            $rootScope.$on('saveScheedule', function () {
                var dialog = document.getElementById("save-dialog");
                dialog.toggle();
            });

            // Initialize blank agenda.
            mb.agenda = AgendaService.blankAgenda();
        };

        // Fired upon clicking a section.
        mb.clickSection = function (section) {
            if (section.active) {
                // If we're clicking a selected section, clear its active flag.
                // Then remove it from the calendar, and return it to the
                // mouseentered state.
                section.active = false;
                mb.agenda.removeSeriesForSection(section);
                mb.highlightSection(section);
            } else {
                // If we clicked an unselected section, exit the mouseentered
                // state. Set its active flag and add it to the agenda.
                mb.unhighlightSection(section);
                section.active = true;
                mb.agenda.addNormalSeriesForSection(section);
            }
        };

        // Fired when the mosueenter event occurs on a section.
        mb.highlightSection = function (section) {
            // Only add the translucent hover section to the agenda if the section
            // isn't already selected.
            if (!section.active) {
                section.hovering = true;
                mb.agenda.addHoverSeriesForSection(section);
            }
        };

        // Fired when the mosueleave event occurs on a section.
        mb.unhighlightSection = function (section) {
            // Only remove the hover section from the agenda if the section was
            // already being hovered over (i.e. prevent removing selected sections).
            if (section.hovering) {
                section.hovering = false;
                mb.agenda.removeSeriesForSection(section);
            }
        };

        mb.init();
    }
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ScheduleViewerController', ScheduleViewerController);

	/* @ngInject */
	function ScheduleViewerController () {
    	var viewer = this;

    	viewer.init = function () {
    		console.log("Loaded schedule view controller.");
    	}

    	init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.controller('ToolbarController', ['$rootScope',ToolbarController]);

	function ToolbarController ($rootScope) {
		var tc = this;
		tc.init = function () {
			console.log("Loaded toolbar controller.");
		};

		tc.clickSave = function () {
			$rootScope.$broadcast('saveScheedule');
		};

		tc.clickLoad = function () {
			$rootScope.$broadcast('loadScheedule');
		};

		tc.init();
	}
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.filter('ActiveCoursesFilter', ['AgendaModelService', ActiveCoursesFilter]);

		function ActiveCoursesFilter (AgendaModelService) {
			return function(courses) {
				var activeCourses = [];
				angular.forEach(courses, function (course) {
					if (AgendaModelService.activeCourses[course.shortName] !== undefined) {
						activeCourses.push(course);
						// console.log("GOT COURSE");
					} else {
						// console.log("NOT COURSE");
					}
				});
				return activeCourses;
			};
		}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('AgendaModelService', AgendaModelService);

    function AgendaModelService () {
        var ams = this;

        ams.init = function () {
            ams.activeCourses = {};
            ams.operationList = [];
            ams.availableColorIndices = [0,1,2,3,4,5,6,7];
        };

        ams.verifyOperation = function (operation) {
            if (operation.type == "add") {
                return {success: true};
            } else if (operation.type == "add-hover") {
                return {success: true};
            } else if (operation.type == "remove") {
                if (ams.activeCourses[operation.section.courseId][operation.section.id] === undefined) {
                    return {success: false, err: "DOES_NOT_EXIST"};
                }
                return {success: true};
            } else {
                return {success: false, err: "DUPLICATE"};
            }
        };

        ams.mutateSchedule = function (operation, seriesData, errCallback) {
            var verifyStatus = ams.verifyOperation(operation);
            if (verifyStatus.success) {
                ams.operationList.push(operation);
                ams.executeOperation(operation, seriesData);
            } else {
                var shouldContinue = errCallback(verifyStatus.err);
                if (shouldContinue) {
                    ams.executeOperation(operation, seriesData);
                }
            }
        }

        ams.executeOperation = function (operation, seriesData) {
            if (operation.type == "add" || operation.type == "add-hover") {
                ams.executeAddOperation(operation, seriesData);
            } else if (operation.type == "remove") {
                ams.executeRemoveOperation(operation, seriesData);
            }
        };

        ams.executeAddOperation = function (operation, seriesData) {
            var newSeries = [];

            if (operation.type == "add-hover") {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,true));
                }
            } else {
                for (var day of operation.section.days) {
                    newSeries.push(ams.seriesPointForSectionDay(operation.section,day,false));
                }
            }

            // Add course to map of active courses if not already extant
            if (ams.activeCourses[operation.section.courseId] === undefined) {
                // Initialize the active course object with an empty map of secitons
                ams.activeCourses[operation.section.courseId] = {};

                // Color index was already set in ams.seriesPointForSectionDay
                ams.activeCourses[operation.section.courseId].colorIndex = ams.availableColorIndices[0];
                ams.availableColorIndices.splice(0,1);
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                }

                // Add our new series to the calendar
                seriesData.push(newSeries);
                ams.activeCourses[operation.section.courseId].index = seriesData.indexOf(newSeries);

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = 0;

                // Finally, increment the number of sections for our course
                ams.activeCourses[operation.section.courseId].sectionCount = 1;
            } else {
                // Otherwise, just add the new series to the array for our course
                for (var seriesPoint of newSeries) {
                    seriesPoint.colorIndex = ams.activeCourses[operation.section.courseId].colorIndex;
                    seriesData[ams.activeCourses[operation.section.courseId].index].push(seriesPoint);
                }

                // Set the index of the first item in our new series in the array of items for our course
                ams.activeCourses[operation.section.courseId][operation.section.id] = seriesData[ams.activeCourses[operation.section.courseId].index].indexOf(newSeries[0]);
                ams.activeCourses[operation.section.courseId].sectionCount++;
            }
        }

        ams.executeRemoveOperation = function (operation, seriesData) {
            // Get index for our section
            var sectionIndex = ams.activeCourses[operation.section.courseId][operation.section.id];

            // Get course index
            var courseIndex = ams.activeCourses[operation.section.courseId].index;

            // Set entry in our course object for the section to be removed as undefined
            ams.activeCourses[operation.section.courseId][operation.section.id] = undefined;

            // Splice out n entries from our course's array in seriesData starting at our section index, where
            // n is the number of days for our section.
            seriesData[courseIndex].splice(sectionIndex,operation.section.days.length);

            // Iterate over our course object properties to find all entries corresponding to section indecies
            for (var property in ams.activeCourses[operation.section.courseId]) {
                // If the property is strictly numeric...
                if (ams.activeCourses[operation.section.courseId].hasOwnProperty(property) && ams.isNumeric(property)) {
                    // Get the index for each section
                    var candidateSectionIndex = ams.activeCourses[operation.section.courseId][property];
                    // If this candidate index is greater than the index of the section we just removed from
                    // our course's array in seriesData, we have to reindex. Subtract the number of items we
                    // spliced out from the section's index.
                    if (candidateSectionIndex > sectionIndex) {
                        ams.activeCourses[operation.section.courseId][property] -= operation.section.days.length;
                    }
                }
            }
            ams.activeCourses[operation.section.courseId].sectionCount--;
            if (ams.activeCourses[operation.section.courseId].sectionCount == 0) {
                var courseIndex = ams.activeCourses[operation.section.courseId].index;
                ams.availableColorIndices.unshift(ams.activeCourses[operation.section.courseId].colorIndex);
                ams.activeCourses[operation.section.courseId] = undefined;
                seriesData.splice(courseIndex,1);
                // Our course table needs to be reindexed in the same way as above
                for (var property in ams.activeCourses) {
                    if (ams.activeCourses.hasOwnProperty(property) && property != 'index' && property != 'sectionCount' && property != operation.section.courseId && ams.activeCourses[property] !== undefined) {
                        var candidateCourseIndex = ams.activeCourses[property].index;
                        if (candidateCourseIndex > courseIndex) {
                            ams.activeCourses[property].index -= 1;
                        }
                    }
                }
            }
        }

        ams.seriesPointForSectionDay = function (section, day, hover) {
            var point = {
                x: day,
                y: section.startMoment.hours(),
                name: section.name,
                courseName: section.courseName,
                decimalHours: (section.endMoment.unix() - section.startMoment.unix())/3600.0,
                type: "normal"
            };
            if (hover) {
                point.type = "hover";
            }
            return point;
        };

        
        ams.isNumeric = function (num) {
            return !isNaN(parseFloat(num)) && isFinite(num);
        };

        ams.init();
    }
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('AgendaService', ['AgendaModelService', AgendaService]);

    // Agenda Service
    // ----------------
    //
    // Provides API wrapper around an agenda view. Allows for adding sections, removing sections.
    // Uses Agenda Model Service to provide feedback on these operations (adding a duplicate course,
    // removing a non-existent section).
    function AgendaService (AgendaModelService) {
        var as = this;
        var agenda = {};
        as.ams = AgendaModelService;

        // Initialize service. Set displayed hour range.
        // Create functions on chart objects and initialize
        // chart data.
        as.init = function () {
            as.maxHour24 = 18;
            as.minHour24 = 6;

            as.initChartData();
            as.initChartFunctions();    
        };

        // Add functions to calendar object returned by service.
        as.initChartFunctions = function () {

            // Call into model service. Mutate schedule with add operation.
            // Alert "Duplicate section" if adding a duplicate section. Return success value.
            agenda.addNormalSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "add",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DUPLICATE") {
                        alert("Duplaicate section, adding anyway.");
                        return true;
                    }
                    return false;
                });
            };

            // Call into model service. Mutate schedule with add operation.
            // Do not alert "Duplicate section" if adding a duplicate section.
            // Return success value.
            agenda.addHoverSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "add-hover",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DUPLICATE") {
                        alert("Duplaicate section, adding anyway.");
                        return true;
                    }
                    return false;
                });
            };

            // Call into model service. Mutate schedule with remove operation.
            // Alert "non-existent section" if removing a section not on agenda.
            agenda.removeSeriesForSection = function (section) {
                AgendaModelService.mutateSchedule({
                    type: "remove",
                    section: section,
                },
                agenda.chartData.series,
                function (err) {
                    if (err == "DOES_NOT_EXIST") {
                        alert("We couldn't find the section you're trying to remove.");
                        return true;
                    }
                    return false;
                });
            };
        }

        // Set up drawing function on chart object, set chart options.
        as.initChartData = function () {
            AgendaModelService.maxHour24 = 18;
            AgendaModelService.minHour24 = 6;
            agenda.chartEvents = {
                draw: function eventHandler(data) {
                    if (data.type === 'point') {
                        var w = data.axisX.axisLength/(data.axisX.ticks.length-1);
                        var newSvgElement = new Chartist.Svg('rect', {
                            x: data.x,
                            y: data.y,
                            width: w,
                            height: data.axisY.options.offset*data.series[data.index].decimalHours,
                            opacity: 1.0
                        }, '');
                        newSvgElement._node.addEventListener('removeFromAgenda', function (e) {
                            newSvgElement.removeClass('agenda-fade-in');
                            newSvgElement.addClass('agenda-fade-out');
                        }, true);
                        if (data.series[data.index].type == "hover") {
                            newSvgElement.addClass('agenda-hover');
                            newSvgElement.addClass('agenda-fade-in');
                            newSvgElement.addClass('agenda-color-hover');
                        } else {
                            newSvgElement.addClass('agenda-color-'+data.series[data.index].colorIndex);
                        }
                        data.element.replace(newSvgElement);
                        data.group.elem('text', {
                            x: data.x,
                            y: data.y+25, 
                            fill: "white"
                        }).text(
                            data.series[data.index].courseName+" - "+data.series[data.index].name
                        );
                    }
                }
            };

            // Label interpolation function determines how our axes are labled.
            agenda.chartOptions = {
                seriesBarDistance: 0,
                showLine: false,
                axisY: {
                    labelInterpolationFnc: function (value) {
                        value = as.minHour24 + as.maxHour24 - value;
                        if (value == 12) {
                            return value + ":00 PM"
                        } else if (value > 12) {
                            value = value % 12;
                            return value + ":00 PM"
                        } else {
                            return value + ":00 AM"
                        }
                    },
                    onlyInteger: true,
                    high: 18,
                    low: 6,
                },
                axisX: {
                    type: Chartist.AutoScaleAxis,
                    high: 5,
                    low: 0,
                    onlyInteger: true,
                    labelInterpolationFnc: function(value) {
                        if (value == 0) {
                            return "Monday";
                        } else if (value == 1) {
                            return "Tuesday";
                        } else if (value == 2) {
                            return "Wednsday";
                        } else if (value == 3) {
                            return "Thursday";
                        } else if (value == 4) {
                            return "Friday";
                        }
                    },
                }
            };

            // Set columns on chart. Set series data to be nothing initially.
            agenda.chartData = {
                labels: ['Monday', 'Tuesday', 'Wednsday', 'Thursday', 'Friday'],
                series: []
            };
        }

        // Return blank agenda object, all set up and ready to be used.
        as.blankAgenda = function () {
            return agenda;
        }

        as.init();
    }
})();;(function () {
	"use strict";

	angular
		.module('scheedule')
		.service('AuthService', AuthService);

	function AuthService () {
		var as = this;

		as.init = function () {
			window.onSignIn = as.onSignIn;
		};

		as.onSignIn = function (googleUser) {
			var id_token = googleUser.getAuthResponse().id_token;
			console.log(id_token);
			$.post('/api/oauth/', {token: id_token});
		};

		as.init();
	}
})();;(function () {
    "use strict";

    angular
        .module('scheedule')
        .service('CourseDataService', ['$http', CourseDataService]);

    function CourseDataService ($http) {
        var cds = this;
        console.log("Loaded course data service.");

        cds.init = function () {
            cds.timeFormat = "hh:mm a";
        }

        cds.getCourses = function (processPartialCourses, processErr) {
            $http.get('/api/prx/course/all').then(function (courses) {
                cds.tempCourseData = courses.data;
                cds.courseToProcessIndex = 0;
                setTimeout(function () {
                    cds.formatCourseArray(processPartialCourses);
                }, 1);
            }, function (err) {
                processErr(err);
            });
        };

        cds.formatCourseArray = function (partialCompletionCallback) {
            var course = cds.tempCourseData[cds.courseToProcessIndex];
            var formattedCourse = {
                shortName: course.Department + " " + course.CourseNumber,
                longName: course.Name,
                id: course.ID,
                sections: []
            };
            for (var section of course.Sections) {
                formattedCourse.sections = cds.formatSectionsArray(formattedCourse,course.Sections);
            }
            partialCompletionCallback([formattedCourse]);
            cds.courseToProcessIndex++;
            if (cds.courseToProcessIndex < cds.tempCourseData.length) {
                setTimeout(function () {
                    cds.formatCourseArray(partialCompletionCallback);
                },1);
            }
            // console.log("Finished formatting course array.");
        }

        cds.formatSectionsArray = function (course, sections) {
            var formattedSections = [];
            for (var section of sections) {
                for (var meeting of section.Meetings) {
                    var days = cds.getDayIndicesFromInitialString(meeting.Days);
                    var startDate = moment(meeting.Start,cds.timeFormat);
                    var endDate = moment(meeting.End,cds.timeFormat);
                    formattedSections.push({
                        id: section.CRN,
                        courseId: course.shortName,
                        courseName: course.shortName,
                        name: section.Code,
                        startMoment: startDate,
                        endMoment: endDate,
                        days: days,
                        active: false,
                        hovering: false
                    });
                }
            }
            return formattedSections;
        }

        cds.getDayIndicesFromInitialString = function (initialString) {
            var days = [];
            for (var letterIndex = 0; letterIndex < initialString.length; letterIndex++) {
                var dayInitial = initialString.charAt(letterIndex);
                if (dayInitial == 'M') {
                    days.push(0);
                } else if (dayInitial == 'T') {
                    days.push(1);
                } else if (dayInitial == 'W') {
                    days.push(2);
                } else if (dayInitial == 'R') {
                    days.push(3);
                } else if (dayInitial == 'F') {
                    days.push(4);
                }
            }
            return days;
        }
        
        cds.init();
    }
})();